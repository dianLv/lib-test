### 网络
* 消息
	* 通讯/传输
		* 客户端生成数据->封包处理->网络/路由传输->网关服务器分发->逻辑服务器处理，根据链路来源进行返回
		* 长连接+自定义协议格式+内容(对称加密，如AES)
	* 安全
		* 消息校验
			* 消息头，涉及长度、版本、消息枚举、自增id等内容
			* 消息体(数据段)
				* 字段定义(如 Protobuf)
				* 加密/解密
				* 压缩
		* (大)数据包的完整性
		* 防刷/反刷
			* 包频率限制(单位时间内最大包数量)
			* id自增，防止重发
			* 图形识别码(防注册、创角)
			* 身份验证交互
			* 行为(特征)分析等
* 接口(协议)
	* 常规风险
		* 消息重发
		* 数据嫁接
		* 参数伪造
		* (业务)请求顺序混乱等
	* 验证内容
		* 伪造客户端请求，如
			* 数量、次数等
			* 等级、任务、进度、资源、位置、状态等
			* 权限(组队、工会等)
			* 时间(非活动时间)
			* 敏感字
			* 非枚举数值
		* 伪造与其他玩家的交互，如
			* 防止转发异常数据
			* 防止伪造消息对正常客户端的影响
		* 异常消息引发的服务器异常(无响应，卡顿、阻塞、崩溃等)
		* 防止特殊(未开放、预留、一次性)接口被滥用
			* 如，教程中用于发放资源的接口被重复调用
		* 收集并确认经过接口测试锻炼账号的游戏表现(用于识别异常用户)
		* 溯源大部分网络问题，往往在于其接口实现的健壮性不足
	* 功能拓展
		* **协议录制**(用于压测的真人模拟)
		* 监听前后端交互过程(如 Npcap)，补充常规测试，如
			* 收发时间(时机)
			* 收发内容(顺序)
			* 收发包的大小(影响弱网情况下的表现)
			* 单位时间内收发包的频率(协议引起的性能问题)
			* 单位时间内特定包的频率
		* 基于接口的机器人，如
			* 维持在线人数
			* 维持场景人数
			* 维持前后端交互频率
			* 模拟组队、副本等
			* 压测
			* 其他
	* 关注点
		* 网关消息分发与客户端消息处理的平衡
		* 对消息传递的加解密的处理
			* 使用非加密接口进行测试
			* 根据加解密过程进行实现
* 弱网->(时延、丢包、抖动、带宽等)低效传输导致消息收发时间的无限延长
	* 提示机制，如 Loading、文本弹框
	* 影响
		* 无法进入游戏(登录时需要拉取大量数据)
		* 同步异常->移动、技能释放等
		* 引起断线(会话中断、心跳超时)
		* 请求超时(涉及重试机制的处理)
		* 消息堆积
* 断线/重连
	* 断线原因->物理层(连接断开)，逻辑层(会话断开))
		* 客户端
			* 网络中断(物理)
				* 网络切换
				* wifi/数据流量关闭
				* 来电
			* 挂后台、锁屏
			* 请求被阻塞(如，服务器响应异常)
			* 释放连接(或退出游戏)
		* 服务器
			* 账号异常(如，封禁、防沉迷等)
			* 登录异常(如，频繁登录、顶号等)
			* 客户端心跳超时
			* 客户端行为消极或异常(如，挂机、反外挂等)
			* 服务器关闭、重启
			* 服务器更新、维护
			* 服务器异常，如
				* 响应异常(如 响应超时、不响应或响应时间长)
					* 服务器负载压力大
					* 服务器带宽受限
					* 服务器消息异常等
				* 关键服务挂起、崩溃
	* 断线时机
		* 客户端发送消息前连接中断
		* 客户端发送消息的过程中连接中断
		* 服务器发送消息的过程中连接中断
		* 其他，如
			* 登录验证过程中，发生断线
				* 客户端登录服务器时断线(未能登录服务器)
				* 客户端登录服务器的过程中断线(loading过程)
			* 登录排队过程中，发生断线
			* 服务器主动断开与客户端的连接
	* 断线影响
		* 交互异常
			* 无法进入游戏
			* 无法继续操作
		* 客户端异常与闪退，如
			* 界面卡死
			* 卡状态，技能的释放状态无法退出
			* 异常引起的闪退
		* 前后端(对象)数据不一致(如位置、场景、状态、组队等)
		* 系统间状态不统一，如 会话状态、登录状态等
		* 玩法中断或失败，核心奖励丢失
		* 用户离线时还涉及在线玩家管理，数据存盘等事件
	* 断线重连
		* 重连方式
			* 强感知
				* (强制)弹窗选择(涉及UI层级)
				* 重新登录(如，角色大厅、登录界面)
			* 低感知->自动重连
			* 基于断线原因
		* 无法重连
			* 客户端网络未恢复
			* 服务器连接失败->对应处理与提示
				* 服务器未开启
				* 客户端未更新(版本不一致)
				* 服务器在线人数限制、单位时间内登录人数限制等
				* 服务器状态异常
					* 服务器中保留前登录状态导致的无法登录
				* 账号异常
		* 重连检查(网络恢复后)
			* 重连后能否正常同步消息
			* 重连后是否出现前后端数据不一致，如
				* 断线后将玩家踢出当前场景，重连后未同步位置信息
				* 断线期间经验变化导致的等级不一致(及其他数值相关)
				* 服务器保护或托管状态能否解除
			* 客户端是否记录断线期间的操作并在恢复后重新发送(涉及会话状态衔接)
			* 重连是否对服务器缓存机制产生影响(如，写/读操作同时发生)
		* 常见问题，如
			* 登录角色的过程中掉线能否重连
			* 登录排队过程中断线重连如何处理(是否进行保护)
			* 创建角色的过程中的掉线处理问题
			* 跨服期间的断线重连能否继续跨服
			* 玩法是否存在断线保护机制(设计上是否对掉线情况进行预设)
			* 在服务器同步数据量大的情况下能否重连
			* 在服务器刷新时间点附近进行断线重连，数据能否正常刷新
			* 在新手引导过程中进行断线重连操作，引导能否正常进行
			* 是否出现同时在线(离线被顶，顶号机制相关)
			* 是否对服务器内部模块产生影响
			* 是否对重连失败的情况进行再处理
			* 客户端本地数据(如在线时间)是否刷新
			* 客户端关闭连接后尝试发送消息，能否自动触发掉线重连等
### 性能
* 前端(略)
* 后端
	* 压测准备
		1. 理清服务器架构(服务器软硬件+内外部组件)
		2. 梳理业务流程与服务器模块映射关系
		3. 重点事务(如，登录登出，社交，交易，副本，战斗、玩法交互等)
	* 压测方式->机器人程序(模拟通讯)，真机
	* 压测对象
		* 程序
			* 提测版本
			* 编译模式(debug?release?)
			* 是否预热
		* 配置x部署
			* 生产环境 or 测试环境
			* 日志开关、级别->主要影响磁盘和cpu等
			* 功能开放程度(游戏内容与服务器时间高度关联)
				* 参数与策略
		* 其他，如 硬件、第三方组件、中间件
	* 负载均衡
		* 目标上线(在线人数)，上线时cpu，内存，带宽负载状况
		* 模块间横向扩展能力(静态扩展，动态扩展)
			* 模块是否具备扩展能力
			* 扩展后的压力释放后能否回收(缩容能力)
			* 跨设备间的扩展能力
	* 容灾备灾(可恢复/不可恢复)
		* 备份机制
			* 备份方式(热备、冷备、双活等)
			* 备份时机(定时、运维时)
			* 备份恢复(回档)等
		* 恢复时间(如，重启恢复(自动拉起)，涉及故障排除的运维恢复、程序恢复)
	* 过载保护
		* 在线(人数)控制
			* 最大在线上限，踢出，登录: 排队 or 拒绝服务(引导至新服务器)
		* 注册限制(何时关闭注册)
			* 最大注册上限
			* 单位时间内注册上限
		* 玩法控制(限制房间数量、增加排队时间)
* 3个维度
	* 能力验证
	* 机制验收
	* 查漏补缺
### 兼容性
* (UI)分辨率，定位
* 跨语言的兼容(排版、数值呈现、内容特化)
* 设备/平台等
	* 应用间兼容(输入法、电话等)
	* 权限的兼容(相同平台还存在版本间权限差异)
* 开发环境与生产环境的兼容->如，文件读取
### 安全(简)
* Cocos2dx Lua
	* so去符号化(进一步抹除函数名、相关字符串)
	* 使用xxtea对资源进行保护, 并隐藏sign、**KEY**在so中的痕迹
		* 此外, 防止特定函数的传参被劫持(从而实现自解)
	* 防止luaL_loadbuffer、cpparser、lj_bcread等函数的直接暴露
	* 以luajit为例(通常手段)
		* 编译为字节码使用
		* 修改字节码开头的MagicNumber
		* 调整OpCode顺序
		* 调整GCproto中的内存布局(如调整numparams、framesize顺序)
		* 对sizeuv等number值进行**异或**处理
		* 核心目的: 增加反编译(ljd/luajit-decompiler-v2等)的难度
	* 避免通讯秘钥在c++和lua间相互传递
	* 在lua中，对关键数据的访问进行修饰(避免暴露内存位置)
* 对不同平台、不同代理商，使用不同的秘钥
* 采用md5等算法需要加盐使用
* 安卓apk加壳(受应用商店的机器审核影响，存在无法上架的风险)
* 反调试、反frida等略
### 补充
* 备份/回档->快速、0损的测试特定内容
	* 准备账号/角色，完成测试内容的前期准备
	* 停服并完成游戏数据**备份**，记录服务器的当前时间
	* 清档(可省略)
	* 将服务器时间及数据还原，并重新拉起服务器，完成**回档**
		* 失败/失效: 服务器更新(数据结构、玩法配置的变更)
* 用例的生命周期
	* 列出参考->策划案、需求清单、实现方案(技术文档、配表)+交互协议等
		* 策划案->设计意图，参考，预期，规划
		* 需求清单(规则、细节、变更)，UI交互图
		* 实现方案->前端+后端+数据交互，配表
	* 根据参考挖掘出**功能点**(列出清单，包括性能、网络、兼容等)
	* 将功能点映射成**测试点**
	* 将测试点完善为**测试用例**(全量/基础(核心)/精简)
	* 完成测试及问题反馈
		* 需求完成进度
		* 细节匹配程度(需求与实现不可能100%统一)
		* 根据测试结果改进测试用例
		* 当需求或实现发生变动后，从第一步开始重新开始
* 心跳机制(会话)
	* 单向心跳，双向心跳
	* 心跳频率(间隔)
	* 重试机制
		* 已发生重连后，重试次数是否重置
* 一般游戏的登录流程(端游流程在游戏外)
	* 启动游戏
	* logo界面
		* 拉起SDK(通常为了安全，会放在游戏开始时拉起)
		* 资源自检与初始化
		* 游戏版本与资源版本检查(也可能放到登录界面)
			* 差异时，进入更新流程
			* 特殊更新机制->用于自测或灰度
				* ip白名单
				* 特殊配置(重定向到灰度版本服务器)
					* 自行放置
					* 进入服务器时，修改灰度标记
	* 更新流程
		* 弹出更新信息(进度)
		* 资源下载(涉及流量与 WiFi 确认，也可能通过SDK实现)
			* 根据版本获取对应内容
			* 涉及断点续传机制、更新内容的检测
		* 游戏或资源更新完成
			* 返回logo界面(游戏资源更新)
			* 游戏重启(游戏本体更新)
		* 还可能涉及分包
	* 登录界面
* 国际化
	* 政策、法规、监管层面
	* (宗教)风俗习惯层面
	* 汇率、定价层面
		* 汇率及数值产生的溢出
	* 文本、美术字翻译(术语统一)，UI排版
	* 安全策略
* (基础)类型溢出(以c#为例)
``` c#
// 账户余额, 避免0无法进购买逻辑
int accountBalance = 1;
// 商品价格
int goodsPrice = 998;
// 购买数量
int quantity = 2151788;
// 溢出成负值，int[-2147483648~2147483647]
int totalPrice = goodsPrice * quantity;
// 购买金额变成负值
//if(accountBalance > totalPrice) {购买及扣款逻辑...}
```
``` c#
// 无符号类型溢出
uint accountBalance = 555;
uint goodsPrice = 998;
uint quantity = 4303575; // 通过uint.MaxValue/goodsPrice向上取整
// 998 x 4303575 = 554, 超过uint.MaxValue导致溢出
uint totalPrice = goodsPrice * quantity;
//if(accountBalance > totalPrice) {购买及扣款逻辑...}
```